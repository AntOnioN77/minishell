!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/fibo/Escritorio/rama_debugging/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
$(NAME)	Makefile	/^$(NAME): libft\/libft.a $(OBJECTS) $(HEADERS)$/;"	t
$(NAME)	libft/Makefile	/^$(NAME): $(OBJECTS) $(HEADERS)$/;"	t
%.o	Makefile	/^%.o: %.c $(HEADERS)$/;"	t
%.o	libft/Makefile	/^%.o: %.c $(HEADERS)$/;"	t
*.tcc	.vscode/settings.json	/^		"*.tcc": "c",$/;"	s	object:files.associations
3_	.vscode/settings.json	/^		"3_": "cpp"$/;"	s	object:files.associations
ALL_OK	minishell.h	/^	ALL_OK,$/;"	e	enum:e_errors
BONUSOBJ	libft/Makefile	/^BONUSOBJ = $(BONUSSRC:.c=.o)$/;"	m
BONUSSRC	libft/Makefile	/^BONUSSRC = src\/ft_lstnew.c src\/ft_lstadd_front.c src\/ft_lstsize.c\\$/;"	m
BUFFER_SIZE	GNL/get_next_line.h	/^#  define BUFFER_SIZE /;"	d
BUFFER_SIZE	get_next_line.h	/^#  define BUFFER_SIZE /;"	d
Bonus	minishell_tester/README.md	/^# Bonus $/;"	c
CC	Makefile	/^CC = cc$/;"	m
CC	libft/Makefile	/^CC = clang$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -Wextra -Werror$/;"	m
COM_NOT_FOUND	minishell.h	/^	COM_NOT_FOUND = 127,$/;"	e	enum:e_errors
CONTINUE	minishell.h	/^	CONTINUE,$/;"	e	enum:e_errors
CPPFLAGS	Makefile	/^CPPFLAGS = -I. -I\/libft\/headers $/;"	m
C_Cpp.codeLens	.vscode/settings.json	/^    "C_Cpp.codeLens": "Enabled"$/;"	s
DBGFLAGS	Makefile	/^DBGFLAGS = -g3$/;"	m
DEFAULT_HISTSIZE	minishell.h	/^# define DEFAULT_HISTSIZE /;"	d
DELIMITERS	minishell.h	/^# define DELIMITERS /;"	d
EMPTY_STACK	libft/headers/ring.h	/^#define EMPTY_STACK /;"	d
END_CYCLE	minishell.h	/^	END_CYCLE,$/;"	e	enum:e_errors
ERROR	libft/headers/libft.h	/^#define ERROR /;"	d
ERROR_MALLOC	minishell.h	/^    ERROR_MALLOC = 151, \/\/ evitamos solapar valores de errno, de esta manera$/;"	e	enum:e_errors
EXECUTOR_H	executor.h	/^# define EXECUTOR_H$/;"	d
EXTRAOBJ	libft/Makefile	/^EXTRAOBJ = $(EXTRASRC:.c=.o)$/;"	m
EXTRASRC	libft/Makefile	/^EXTRASRC =ring_array\/ring_next_index.c ring_array\/ring_prev_index.c\\$/;"	m
E_SIGINT	minishell.h	/^	E_SIGINT = 130,$/;"	e	enum:e_errors
E_SIGQUIT	minishell.h	/^	E_SIGQUIT = 131,$/;"	e	enum:e_errors
Extra tests	minishell_tester/README.md	/^# Extra tests$/;"	c
FAIL_BUILTINS_EXE	minishell.h	/^	FAIL_BUILTINS_EXE,			\/\/SOLO ODEBUG BORRAR!!!!!!!!!!!!!!!!!$/;"	e	enum:e_errors
FALSE	libft/headers/libft.h	/^#define FALSE /;"	d
FINISH	minishell.h	/^	FINISH$/;"	e	enum:e_errors
FLAGS	libft/Makefile	/^FLAGS = -Wall -Wextra -Werror$/;"	m
FULL_STACK	libft/headers/ring.h	/^#define FULL_STACK /;"	d
GET_NEXT_LINE_H	GNL/get_next_line.h	/^# define GET_NEXT_LINE_H$/;"	d
GET_NEXT_LINE_H	get_next_line.h	/^# define GET_NEXT_LINE_H$/;"	d
HEADERS	Makefile	/^HEADERS = libft\/headers\/libft.h minishell.h executor.h$/;"	m
HEADERS	libft/Makefile	/^HEADERS = headers\/libft.h$/;"	m
HISTORY_FILE	minishell.h	/^# define HISTORY_FILE /;"	d
How to run	minishell_tester/README.md	/^# How to run $/;"	c
INVALID_TYPE	minishell.h	/^    INVALID_TYPE,\/\/solo para debug	$/;"	e	enum:e_errors
IS_A_DIR	minishell.h	/^	IS_A_DIR = 126,$/;"	e	enum:e_errors
IS_SIGNAL	minishell.h	/^# define IS_SIGNAL /;"	d
Installation	minishell_tester/README.md	/^# Installation $/;"	c
LDFLAGS	Makefile	/^LDFLAGS = -L .\/libft -lft -lreadline$/;"	m
LIBFT_H	libft/headers/libft.h	/^# define LIBFT_H$/;"	d
LINE	minishell.h	/^	LINE,\/\/probablemente innecesario$/;"	e	enum:e_nodes
LINE_TOO_LONG	minishell.h	/^	LINE_TOO_LONG,$/;"	e	enum:e_errors
MINISHELL_H	minishell.h	/^# define MINISHELL_H$/;"	d
Manual tests	minishell_tester/README.md	/^# Manual tests $/;"	c
MinishellTester	minishell_tester.py	/^class MinishellTester:$/;"	c
NAME	Makefile	/^NAME = minishell$/;"	m
NAME	libft/Makefile	/^NAME = libft.a$/;"	m
NONE	minishell.h	/^	NONE,$/;"	e	enum:e_nodes
NO_EXIST	minishell.h	/^	NO_EXIST,$/;"	e	enum:e_errors
NO_PERMISSION	minishell.h	/^	NO_PERMISSION,$/;"	e	enum:e_errors
OBJECTS	Makefile	/^OBJECTS = $(SOURCES:.c=.o)$/;"	m
OBJECTS	libft/Makefile	/^OBJECTS = $(SOURCES:.c=.o)$/;"	m
OBJ_PARS_TEST	Makefile	/^OBJ_PARS_TEST = $(SRC_PARS_TEST:.c=.o)$/;"	m
OK	libft/headers/libft.h	/^#define OK /;"	d
PARSING_H	libft/headers/parsing.h	/^# define PARSING_H$/;"	d
PIPE	minishell.h	/^	PIPE,$/;"	e	enum:e_nodes
READLINE_FAIL	minishell.h	/^	READLINE_FAIL,\/\/lo he cambiado por retornar errno (14feb)$/;"	e	enum:e_errors
READ_SIGINT	minishell.h	/^	READ_SIGINT,$/;"	e	enum:e_errors
REDIR	minishell.h	/^	REDIR,\/\/probablemente innecesario$/;"	e	enum:e_nodes
RING_H	libft/headers/ring.h	/^#define RING_H$/;"	d
SOURCES	Makefile	/^SOURCES = main.c mooks.c parser\/4_check_tree.c parser\/2_build_tree\/constructors.c\\$/;"	m
SOURCES	libft/Makefile	/^SOURCES = src\/ft_atoi.c src\/ft_bzero.c src\/ft_calloc.c\\$/;"	m
SRC_PARS_TEST	Makefile	/^SRC_PARS_TEST = mooks.c parser\/2_build_tree\/build_tree\/constructors.c\\$/;"	m
SYNTAX	minishell.h	/^	SYNTAX$/;"	e	enum:e_nodes
SYNTAX_ERROR	minishell.h	/^	SYNTAX_ERROR,$/;"	e	enum:e_errors
S_LINE_MAX	minishell.h	/^# define S_LINE_MAX /;"	d
Separate tests	minishell_tester/README.md	/^# Separate tests$/;"	c
TASK	minishell.h	/^	TASK,$/;"	e	enum:e_nodes
TASK_IS_VOID	minishell.h	/^	TASK_IS_VOID,	$/;"	e	enum:e_errors
TMP_FILE_ERROR	minishell.h	/^	TMP_FILE_ERROR,$/;"	e	enum:e_errors
TRUE	libft/headers/libft.h	/^#define TRUE /;"	d
WHITESPACES	minishell.h	/^# define WHITESPACES /;"	d
__init__	minishell_tester.py	/^    def __init__(self, minishell_path=".\/minishell"):$/;"	m	class:MinishellTester
__node_handle	.vscode/settings.json	/^		"__node_handle": "c",$/;"	s	object:files.associations
add_var	create_envp.c	/^e_errors add_var(char *key, char *value, t_environ *environ)$/;"	f	typeref:typename:e_errors
all	Makefile	/^all: $(NAME)$/;"	t
all	libft/Makefile	/^all: $(NAME)$/;"	t
alloced	minishell.h	/^	int alloced; \/\/numero total de posiciones allocadas, de manera que si next+1 < alloced, no se/;"	m	struct:s_environ	typeref:typename:int
append	minishell.h	/^	append\/\/>>$/;"	e	enum:e_symbols
apply_redirs	executor/apply_redirs.c	/^e_errors apply_redirs(t_redir *redir, char **word_fail)$/;"	f	typeref:typename:e_errors
argv	minishell.h	/^	char		**argv;$/;"	m	struct:s_task	typeref:typename:char **
atod_int	libft/src/ft_atod.c	/^static double	atod_int(const char *nptr, int *j)$/;"	f	typeref:typename:double	file:
bad_redir	parser/4_check_tree.c	/^int bad_redir(t_redir *redir)$/;"	f	typeref:typename:int
bonus	libft/Makefile	/^bonus: $(OBJECTS) $(BONUSOBJ)$/;"	t
buff	libft/headers/ring.h	/^	int	*buff;$/;"	m	struct:s_ring	typeref:typename:int *
build_tree	parser/2_build_tree/build_tree.c	/^t_tree *build_tree(char *line)\/\/debe retornar un arbol con un nodo para cada fraccion del coma/;"	f	typeref:typename:t_tree *
builtins_exe	executor/executor.c	/^e_errors builtins_exe(t_task *task, t_environ *environ)$/;"	f	typeref:typename:e_errors
calc_abs	libft/src/ft_itoa.c	/^static unsigned int	calc_abs(const int n, int *sign)$/;"	f	typeref:typename:unsigned int	file:
calc_abs	libft/src/ft_putnbr_fd.c	/^static unsigned int	calc_abs(const int n)$/;"	f	typeref:typename:unsigned int	file:
calculate_expansion_length	parser/1_expansor/expansor_utils.c	/^int	calculate_expansion_length(char *str, char *envp[])$/;"	f	typeref:typename:int
change_var	create_envp.c	/^e_errors change_var(char *key, char *newvalue, t_environ *environ)$/;"	f	typeref:typename:e_errors
check_file	parser/2_build_tree/get_redir.c	/^void check_file(char *segment, char *end, t_redir *redir)$/;"	f	typeref:typename:void
check_tree	parser/4_check_tree.c	/^int	 check_tree(t_tree *tree, char **envp)$/;"	f	typeref:typename:int
child_error_handler	executor/executor.c	/^static e_errors child_error_handler(e_errors err, char *cmd)$/;"	f	typeref:typename:e_errors	file:
child_error_handler_fail	minishell.h	/^	child_error_handler_fail,   \/\/SOLO ODEBUG BORRAR!!!!!!!!!!!!!!!!!$/;"	e	enum:e_errors
clean	Makefile	/^clean:$/;"	t
clean	libft/Makefile	/^clean:$/;"	t
cleanup_garbage	free.c	/^static void cleanup_garbage(t_garbage *garbage)$/;"	f	typeref:typename:void	file:
close	minishell_tester.py	/^    def close(self):$/;"	m	class:MinishellTester
close_fds	executor/process.c	/^void close_fds(int fd_since)$/;"	f	typeref:typename:void
cmd	minishell.h	/^	char		*cmd;$/;"	m	struct:s_task	typeref:typename:char *
com_path	executor/executor.c	/^char *com_path(char *cmd, char **envp, e_errors *err)$/;"	f	typeref:typename:char *
com_path	paluego_jose/exect.c	/^char	*com_path(char *cmd, char **envp)$/;"	f	typeref:typename:char *
compose_filename	parser/create_heredoc.c	/^char *compose_filename(int i, e_errors *error)$/;"	f	typeref:typename:char *
content	libft/headers/libft.h	/^	void			*content;$/;"	m	struct:s_list	typeref:typename:void *
continue_cmd_tree	main.c	/^e_errors	continue_cmd_tree(t_tree **right, char **envp)$/;"	f	typeref:typename:e_errors
copy_prev_envp	create_envp.c	/^e_errors copy_prev_envp(char **original, t_environ *environ)$/;"	f	typeref:typename:e_errors
count_cmdflags	parser/2_build_tree/build_tree.c	/^int count_cmdflags(char *segment, char *end)$/;"	f	typeref:typename:int
count_expansions	parser/1_expansor/expansor_utils.c	/^int	count_expansions(t_task *node)$/;"	f	typeref:typename:int
count_to_null	create_envp.c	/^int count_to_null(void **pnt)$/;"	f	typeref:typename:int
countargs	builtins/non_pipable_builtin.c	/^static int countargs(t_task *task)$/;"	f	typeref:typename:int	file:
countchr	libft/src/ft_itoa.c	/^static int	countchr(int n)$/;"	f	typeref:typename:int	file:
countchr	libft/src/ft_putnbr_fd.c	/^static int	countchr(int n)$/;"	f	typeref:typename:int	file:
create_child	executor/executor.c	/^e_errors create_child(t_task *task, t_environ *environ , int in, int out)$/;"	f	typeref:typename:e_errors
create_envp	create_envp.c	/^e_errors create_envp(char **original, t_environ *environ)$/;"	f	typeref:typename:e_errors
create_file	parser/2_build_tree/get_redir.c	/^void create_file(char *segment, char *end, int flag, t_redir *redir)$/;"	f	typeref:typename:void
create_heredoc	parser/create_heredoc.c	/^e_errors create_heredoc(t_redir *redir)$/;"	f	typeref:typename:e_errors
createpipe	parser/2_build_tree/constructors.c	/^t_tree *createpipe(char *line,char *pnt)$/;"	f	typeref:typename:t_tree *
createtask	parser/2_build_tree/constructors.c	/^t_task *createtask(char *segment, char *end)$/;"	f	typeref:typename:t_task *
current	minishell.h	/^	int		current;$/;"	m	struct:s_garbage	typeref:typename:int
custom_realloc	create_envp.c	/^void *custom_realloc(void **pnt, size_t oldsize, size_t newsize)$/;"	f	typeref:typename:void *
debug	Makefile	/^debug: CFLAGS += $(DBGFLAGS)$/;"	t
debug	Makefile	/^debug: fclean libft\/libft.a $(OBJECTS) $(HEADERS)$/;"	t
distribute	libft/src/ft_putnbr_base.c	/^static int	distribute(int *reminds, unsigned int *unbr, unsigned int len_base)$/;"	f	typeref:typename:int	file:
distribute	libft/src/ft_putunbr_base.c	/^static int	distribute(int *reminds, long unsigned int *unbr,$/;"	f	typeref:typename:int	file:
e_errors	minishell.h	/^typedef enum e_errors$/;"	g
e_errors	minishell.h	/^} e_errors;$/;"	t	typeref:enum:e_errors
e_nodes	minishell.h	/^typedef enum e_nodes$/;"	g
e_nodes	minishell.h	/^}	e_nodes;$/;"	t	typeref:enum:e_nodes
e_symbols	minishell.h	/^typedef enum e_symbols$/;"	g
e_symbols	minishell.h	/^} e_symbols;$/;"	t	typeref:enum:e_symbols
editor.codeLens	.vscode/settings.json	/^	"editor.codeLens": true,$/;"	b
ejecutar_sleep	pruebas/prueba_sigson.c	/^void ejecutar_sleep() {$/;"	f	typeref:typename:void
envp	minishell.h	/^	char **envp;$/;"	m	struct:s_environ	typeref:typename:char **
errno.h	.vscode/settings.json	/^		"errno.h": "c",$/;"	s	object:files.associations
error	minishell.h	/^	e_errors	error; \/\/Error causado durante la creación de tmp_file$/;"	m	struct:s_redir	typeref:typename:e_errors
error_exe	paluego_jose/error_exe.c	/^int	error_exe(int er, char *cmd)$/;"	f	typeref:typename:int
exec_pipe	executor/executor.c	/^e_errors exec_pipe(t_pipe *pipe_node, t_environ *environ, int in)$/;"	f	typeref:typename:e_errors
execute	paluego_jose/exect.c	/^int execute(t_tree *tree, char **envp)$/;"	f	typeref:typename:int
executor	APUNTES/uso_de_stdin_stdout.c	/^int executor(t_tree *node, char **envp)$/;"	f	typeref:typename:int
executor	executor/executor.c	/^e_errors executor(t_tree *node, t_environ *environ , int in, int out)$/;"	f	typeref:typename:e_errors
expand_task	parser/1_expansor/expansor.c	/^e_errors	expand_task(t_task *node, char *envp[])$/;"	f	typeref:typename:e_errors
expandstr	paluego_jose/expansor.c	/^e_errors	expandstr(char **origin, char *envp[]) \/\/envp debe recibir el array de strings que he/;"	f	typeref:typename:e_errors
expandstr	parser/1_expansor/expansor.c	/^e_errors	expandstr(char **origin, t_garbage *garbage, char *envp[]) \/\/envp debe recibir el arr/;"	f	typeref:typename:e_errors
expansor	paluego_jose/expansor.c	/^e_errors expansor(char **line, char **envp)$/;"	f	typeref:typename:e_errors
export_error	builtins/non_pipable_builtin.c	/^void export_error(char* identifier, t_environ *environ)$/;"	f	typeref:typename:void
extra	libft/Makefile	/^extra: $(OBJECTS) $(BONUSOBJ) $(EXTRAOBJ)$/;"	t
extra	libft/Makefile	/^extra: HEADERS += headers\/ring.h headers\/parsing.h$/;"	t
fclean	Makefile	/^fclean: clean$/;"	t
fclean	libft/Makefile	/^fclean: clean$/;"	t
fcntl.h	.vscode/settings.json	/^		"fcntl.h": "c",$/;"	s	object:files.associations
features.h	.vscode/settings.json	/^		"features.h": "c",$/;"	s	object:files.associations
file_redirector	executor/apply_redirs.c	/^static e_errors file_redirector(int newfd, char *file, int openflag, char **word_fail)$/;"	f	typeref:typename:e_errors	file:
files.associations	.vscode/settings.json	/^	"files.associations": {$/;"	o
fill	libft/headers/ring.h	/^	int	fill;$/;"	m	struct:s_ring	typeref:typename:int
find_path	APUNTES/pipex_gethpath.c	/^static int	find_path(char **env, char *command, char *pathname)$/;"	f	typeref:typename:int	file:
findchars	parser/2_build_tree/get_redir.c	/^char *findchars(char *str, char *end, char *wanted)$/;"	f	typeref:typename:char *
foundvar	parser/1_expansor/expansor_utils.c	/^char *foundvar(char *str, char *envp[])$/;"	f	typeref:typename:char *
free_arr	free.c	/^void	free_arr(char **s)$/;"	f	typeref:typename:void
free_null_arr	free.c	/^int	free_null_arr(char ***s)$/;"	f	typeref:typename:int
free_task	free.c	/^void free_task(t_tree *node)$/;"	f	typeref:typename:void
free_tree	free.c	/^void free_tree(t_tree *node) \/\/DEMASIADO LARGA$/;"	f	typeref:typename:void
ft_atod	libft/src/ft_atod.c	/^double	ft_atod(const char *nptr)$/;"	f	typeref:typename:double
ft_atoi	libft/src/ft_atoi.c	/^int	ft_atoi(const char *str)$/;"	f	typeref:typename:int
ft_atol	libft/src/ft_atol.c	/^long	ft_atol(const char *str)$/;"	f	typeref:typename:long
ft_bzero	libft/src/ft_bzero.c	/^void	ft_bzero(void *s, size_t n)$/;"	f	typeref:typename:void
ft_calloc	libft/src/ft_calloc.c	/^void	*ft_calloc(size_t count, size_t size)$/;"	f	typeref:typename:void *
ft_cd	builtins/non_pipable_builtin.c	/^void ft_cd(t_task *task, t_environ *environ)$/;"	f	typeref:typename:void
ft_count_substr	libft/src/ft_split.c	/^static int	ft_count_substr(const char *str, char tkn)$/;"	f	typeref:typename:int	file:
ft_echo	builtins/builtins.c	/^e_errors ft_echo(t_task *task)$/;"	f	typeref:typename:e_errors
ft_env	builtins/builtins.c	/^void ft_env(t_environ *environ)$/;"	f	typeref:typename:void
ft_exit	builtins/non_pipable_builtin.c	/^void ft_exit(t_task *task, t_tree *tree, t_environ *environ)$/;"	f	typeref:typename:void
ft_export	builtins/non_pipable_builtin.c	/^void ft_export(t_task *task, t_environ *environ)$/;"	f	typeref:typename:void
ft_free_null	free.c	/^void ft_free_null(void **pnt)$/;"	f	typeref:typename:void
ft_getenv	create_envp.c	/^char *ft_getenv(const char *name, char *envp[])$/;"	f	typeref:typename:char *
ft_has_duplicates	libft/parsing/ft_has_duplicates.c	/^int ft_has_duplicates(int n_words, char **array_words)$/;"	f	typeref:typename:int
ft_imprime	libft/src/ft_putnbr_base.c	/^static void	ft_imprime(char *base, int *buf_reminds, int nlength)$/;"	f	typeref:typename:void	file:
ft_imprime	libft/src/ft_putunbr_base.c	/^int	ft_imprime(char *base, int *buf_reminds, int nlength)$/;"	f	typeref:typename:int
ft_is_base_ko	libft/src/ft_putnbr_base.c	/^static int	ft_is_base_ko(char *base)$/;"	f	typeref:typename:int	file:
ft_is_base_ko	libft/src/ft_putunbr_base.c	/^static int	ft_is_base_ko(char *base)$/;"	f	typeref:typename:int	file:
ft_is_in_bounds_int	libft/parsing/ft_is_in_bounds_int.c	/^bool	ft_is_in_bounds_int(char *num)$/;"	f	typeref:typename:bool
ft_isalnum	libft/src/ft_isalnum.c	/^int	ft_isalnum(int c)$/;"	f	typeref:typename:int
ft_isalpha	libft/src/ft_isalpha.c	/^int	ft_isalpha(int c)$/;"	f	typeref:typename:int
ft_isascii	libft/src/ft_isascii.c	/^int	ft_isascii(int c)$/;"	f	typeref:typename:int
ft_isdigit	libft/src/ft_isdigit.c	/^int	ft_isdigit(int c)$/;"	f	typeref:typename:int
ft_isprint	libft/src/ft_isprint.c	/^int	ft_isprint(int c)$/;"	f	typeref:typename:int
ft_itoa	libft/src/ft_itoa.c	/^char	*ft_itoa(int n)$/;"	f	typeref:typename:char *
ft_lstadd_back	libft/src/ft_lstadd_back.c	/^void	ft_lstadd_back(t_list **lst, t_list *new)$/;"	f	typeref:typename:void
ft_lstadd_front	libft/src/ft_lstadd_front.c	/^void	ft_lstadd_front(t_list **lst, t_list *new)$/;"	f	typeref:typename:void
ft_lstclear	libft/src/ft_lstclear.c	/^void	ft_lstclear(t_list **lst, void (*del)(void *))$/;"	f	typeref:typename:void
ft_lstdelone	libft/src/ft_lstdelone.c	/^void	ft_lstdelone(t_list *lst, void (*del)(void *))$/;"	f	typeref:typename:void
ft_lstiter	libft/src/ft_lstiter.c	/^void	ft_lstiter(t_list *lst, void (*f)(void *))$/;"	f	typeref:typename:void
ft_lstlast	libft/src/ft_lstlast.c	/^t_list	*ft_lstlast(t_list *lst)$/;"	f	typeref:typename:t_list *
ft_lstmap	libft/src/ft_lstmap.c	/^t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))$/;"	f	typeref:typename:t_list *
ft_lstnew	libft/src/ft_lstnew.c	/^t_list	*ft_lstnew(void *content)$/;"	f	typeref:typename:t_list *
ft_lstsize	libft/src/ft_lstsize.c	/^int	ft_lstsize(t_list *lst)$/;"	f	typeref:typename:int
ft_memchr	libft/src/ft_memchr.c	/^void	*ft_memchr(const void *s, int c, size_t n)$/;"	f	typeref:typename:void *
ft_memcmp	libft/src/ft_memcmp.c	/^int	ft_memcmp(const void *s1, const void *s2, size_t n)$/;"	f	typeref:typename:int
ft_memcpy	libft/src/ft_memcpy.c	/^void	*ft_memcpy(void *dest, const void *src, size_t n)$/;"	f	typeref:typename:void *
ft_memmove	libft/src/ft_memmove.c	/^void	*ft_memmove(void *dest, const void *src, size_t n)$/;"	f	typeref:typename:void *
ft_memset	libft/src/ft_memset.c	/^void	*ft_memset(void *s, int c, size_t n)$/;"	f	typeref:typename:void *
ft_perror	main.c	/^void ft_perror(int error) \/\/IMPORTANTE: impresion debe ser atomica, un solo write, estoa imple/;"	f	typeref:typename:void
ft_putchar_fd	libft/src/ft_putchar_fd.c	/^void	ft_putchar_fd(char c, int fd)$/;"	f	typeref:typename:void
ft_putendl_fd	libft/src/ft_putendl_fd.c	/^void	ft_putendl_fd(char *s, int fd)$/;"	f	typeref:typename:void
ft_putnbr_base	libft/src/ft_putnbr_base.c	/^void	ft_putnbr_base(int nbr, char *base)$/;"	f	typeref:typename:void
ft_putnbr_fd	libft/src/ft_putnbr_fd.c	/^void	ft_putnbr_fd(int n, int fd)$/;"	f	typeref:typename:void
ft_putstr_fd	libft/src/ft_putstr_fd.c	/^void	ft_putstr_fd(char *s, int fd)$/;"	f	typeref:typename:void
ft_putunbr_base	libft/src/ft_putunbr_base.c	/^int	ft_putunbr_base(long unsigned int nbr, char *base)$/;"	f	typeref:typename:int
ft_realloc	paluego_jose/ft_realloc.c	/^void	*ft_realloc(void *ptr, size_t size, size_t resize)$/;"	f	typeref:typename:void *
ft_split	libft/src/ft_split.c	/^char	**ft_split(char const *s, char c)$/;"	f	typeref:typename:char **
ft_strchr	libft/src/ft_strchr.c	/^char	*ft_strchr(const char *s, int c)$/;"	f	typeref:typename:char *
ft_strcmp	libft/src/ft_strcmp.c	/^int	ft_strcmp(const char *s1, const char *s2)$/;"	f	typeref:typename:int
ft_strdup	libft/src/ft_strdup.c	/^char	*ft_strdup(const char *s1)$/;"	f	typeref:typename:char *
ft_striteri	libft/src/ft_striteri.c	/^void	ft_striteri(char *s, void (*f)(unsigned int, char*))$/;"	f	typeref:typename:void
ft_strjoin	libft/src/ft_strjoin.c	/^char	*ft_strjoin(char const *s1, char const *s2)$/;"	f	typeref:typename:char *
ft_strlcat	libft/src/ft_strlcat.c	/^size_t	ft_strlcat(char *dst, const char *src, size_t dstsize)$/;"	f	typeref:typename:size_t
ft_strlcpy	libft/src/ft_strlcpy.c	/^size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize)$/;"	f	typeref:typename:size_t
ft_strlen	libft/src/ft_strlen.c	/^size_t	ft_strlen(const char *s)$/;"	f	typeref:typename:size_t
ft_strmapi	libft/src/ft_strmapi.c	/^char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))$/;"	f	typeref:typename:char *
ft_strnchr	libft/src/ft_strnchr.c	/^char	*ft_strnchr(const char *s, int c, int n)$/;"	f	typeref:typename:char *
ft_strncmp	libft/src/ft_strncmp.c	/^int	ft_strncmp(const char *s1, const char *s2, size_t n)$/;"	f	typeref:typename:int
ft_strndup	libft/src/ft_split.c	/^static char	*ft_strndup(const char *src, int length)$/;"	f	typeref:typename:char *	file:
ft_strnstr	libft/src/ft_strnstr.c	/^char	*ft_strnstr(const char *haystack, const char *needle, size_t len)$/;"	f	typeref:typename:char *
ft_strrchr	libft/src/ft_strrchr.c	/^char	*ft_strrchr(const char *str, int c)$/;"	f	typeref:typename:char *
ft_strtrim	libft/src/ft_strtrim.c	/^char	*ft_strtrim(char const *s1, char const *set)$/;"	f	typeref:typename:char *
ft_substr	libft/src/ft_substr.c	/^char	*ft_substr(char const *s, unsigned int start, size_t len)$/;"	f	typeref:typename:char *
ft_to_chop	libft/src/ft_split.c	/^static int	ft_to_chop(char **array_substrings, int substring_count,$/;"	f	typeref:typename:int	file:
ft_tolower	libft/src/ft_tolower.c	/^int	ft_tolower(int c)$/;"	f	typeref:typename:int
ft_toupper	libft/src/ft_toupper.c	/^int	ft_toupper(int c)$/;"	f	typeref:typename:int
ft_unset	builtins/non_pipable_builtin.c	/^void ft_unset(char **argv, t_environ *environ)$/;"	f	typeref:typename:void
ft_unset_one	builtins/non_pipable_builtin.c	/^void ft_unset_one(char *key, t_environ *environ)$/;"	f	typeref:typename:void
g_ctrlc	main.c	/^int g_ctrlc = 0;$/;"	v	typeref:typename:int
garb	minishell.h	/^	t_garbage	garb;$/;"	m	struct:s_task	typeref:typename:t_garbage
get_cmd_tree	main.c	/^e_errors	get_cmd_tree(t_tree **tree, t_environ *environ)$/;"	f	typeref:typename:e_errors
get_histsize	history.c	/^int		get_histsize(const char *histsize)$/;"	f	typeref:typename:int
get_histsize	paluego_jose/history.c	/^int		get_histsize(const char *histsize)$/;"	f	typeref:typename:int
get_index_path	executor/executor.c	/^int	get_index_path(char **envp)$/;"	f	typeref:typename:int
get_next_line	GNL/get_next_line.c	/^int	get_next_line(int fd, char **line)$/;"	f	typeref:typename:int
get_output	minishell_tester.py	/^    def get_output(self):$/;"	m	class:MinishellTester
get_paths	APUNTES/pipex_gethpath.c	/^static char	**get_paths(char **envp)$/;"	f	typeref:typename:char **	file:
get_redir	parser/2_build_tree/get_redir.c	/^void	get_redir(char **segment, char *end, t_redir *redir)$/;"	f	typeref:typename:void
get_tmp_name	parser/create_heredoc.c	/^char *get_tmp_name(e_errors *error)$/;"	f	typeref:typename:char *
getkey	parser/1_expansor/expansor_utils.c	/^char *getkey(char *var)$/;"	f	typeref:typename:char *
getpntword	parser/2_build_tree/build_tree.c	/^void	getpntword(char **segment, char *end, char **dst)$/;"	f	typeref:typename:void
getvalue	builtins/non_pipable_builtin.c	/^char *getvalue(char *var)$/;"	f	typeref:typename:char *
gnl_strchr	GNL/get_next_line.c	/^int	gnl_strchr(const char *s, int c)$/;"	f	typeref:typename:int
gnl_strjoin	GNL/get_next_line.c	/^char	*gnl_strjoin(char *s1, char const *s2)$/;"	f	typeref:typename:char *
handle_append	parser/2_build_tree/get_redir.c	/^static void handle_append(char **segment, char *end, t_redir *redir)$/;"	f	typeref:typename:void	file:
handle_dollar	parser/1_expansor/expansor_utils.c	/^int handle_dollar(char **new_str, char **str, char **marker, char *envp[])$/;"	f	typeref:typename:int
handle_heredoc	parser/2_build_tree/get_redir.c	/^static void handle_heredoc(char **segment, char *end, t_redir *redir)$/;"	f	typeref:typename:void	file:
handle_input	parser/2_build_tree/get_redir.c	/^static void handle_input(char **segment, char *end, t_redir *redir)$/;"	f	typeref:typename:void	file:
handle_output	parser/2_build_tree/get_redir.c	/^static void handle_output(char **segment, char *end, t_redir *redir)$/;"	f	typeref:typename:void	file:
handle_pipe_node	parser/3_touch_up_tree.c	/^static e_errors	handle_pipe_node(t_pipe *pipe, char *envp[])$/;"	f	typeref:typename:e_errors	file:
handle_sigint	signal.c	/^void	handle_sigint(int signal)$/;"	f	typeref:typename:void
handle_sigint_heredoc	signal.c	/^void	handle_sigint_heredoc(int signal)$/;"	f	typeref:typename:void
handle_sigint_vis	signal.c	/^void	handle_sigint_vis(int signal)$/;"	f	typeref:typename:void
handle_task_node	parser/3_touch_up_tree.c	/^static e_errors	handle_task_node(t_task *task, char *envp[])$/;"	f	typeref:typename:e_errors	file:
handler_child	pruebas/prueba_sigson.c	/^void handler_child(int signal)$/;"	f	typeref:typename:void
handlerr	main.c	/^e_errors handlerr(e_errors error, t_tree **tree, t_environ *environ)$/;"	f	typeref:typename:e_errors
head	libft/headers/ring.h	/^	int	head;$/;"	m	struct:s_ring	typeref:typename:int
heredoc	minishell.h	/^	heredoc,\/\/<<$/;"	e	enum:e_symbols
heredoc_writer	parser/create_heredoc.c	/^e_errors heredoc_writer(char *separator, t_redir *redir)$/;"	f	typeref:typename:e_errors
history.h	.vscode/settings.json	/^		"history.h": "c",$/;"	s	object:files.associations
infile	minishell.h	/^	infile,\/\/<$/;"	e	enum:e_symbols
infoo	minishell.h	/^	char		*infoo;\/\/ será un archivo para <, O un separator para <<$/;"	m	struct:s_redir	typeref:typename:char *
init_envp	create_envp.c	/^e_errors init_envp(t_environ *environ) $/;"	f	typeref:typename:e_errors
insymbol	minishell.h	/^	e_symbols	insymbol;\/\/< o <<$/;"	m	struct:s_redir	typeref:typename:e_symbols
ios	.vscode/settings.json	/^		"ios": "c",$/;"	s	object:files.associations
is_absolutepath	executor/executor.c	/^static int is_absolutepath(char *cmd, e_errors *err)$/;"	f	typeref:typename:int	file:
is_builtin	executor/executor.c	/^int is_builtin(char *cmd)$/;"	f	typeref:typename:int
is_closed_quote	parser/1_expansor/expansor_utils.c	/^int is_closed_quote(char *str)$/;"	f	typeref:typename:int
is_expansible	parser/1_expansor/expansor_utils.c	/^int	is_expansible(char *str)$/;"	f	typeref:typename:int
is_void_task	parser/4_check_tree.c	/^int is_void_task(t_task *task)$/;"	f	typeref:typename:int
isdelimiter	parser/2_build_tree/str_utils.c	/^int isdelimiter(char c)$/;"	f	typeref:typename:int
left	minishell.h	/^	t_task	*left;$/;"	m	struct:s_pipe	typeref:typename:t_task *
libft.h	.vscode/settings.json	/^		"libft.h": "c",$/;"	s	object:files.associations
libft/libft.a	Makefile	/^libft\/libft.a:$/;"	t
line	minishell.h	/^	char	*line;		\/\/solo el primer nodo del arbol contendrá line!=NULL$/;"	m	struct:s_pipe	typeref:typename:char *
line	minishell.h	/^	char	*line;		\/\/solo el primer nodo del arbol contendrá line!=NULL$/;"	m	struct:s_task	typeref:typename:char *
line	minishell.h	/^	char	*line;		\/\/solo el primer nodo del arbol contendrá line!=NULL$/;"	m	struct:s_tree	typeref:typename:char *
line_extra	minishell.h	/^	char	*line_extra;\/\/Solo en caso de "ls|(vacio)" line_extra !=NULL$/;"	m	struct:s_pipe	typeref:typename:char *
line_extra	minishell.h	/^	char	*line_extra;\/\/Solo en caso de "ls|(vacio)" line_extra !=NULL$/;"	m	struct:s_task	typeref:typename:char *
line_extra	minishell.h	/^	char	*line_extra;\/\/Solo en caso de "ls|(vacio)" line_extra !=NULL$/;"	m	struct:s_tree	typeref:typename:char *
load_history	paluego_jose/history.c	/^void	load_history(void)$/;"	f	typeref:typename:void
local	minishell.h	/^	char **local;$/;"	m	struct:s_environ	typeref:typename:char **
localloced	minishell.h	/^	int localloced;$/;"	m	struct:s_environ	typeref:typename:int
locnext	minishell.h	/^	int locnext;$/;"	m	struct:s_environ	typeref:typename:int
main	main.c	/^int main(int argc, char **argv, char **envp)$/;"	f	typeref:typename:int
main	minishell_tester/test_files/loop.c	/^int	main(int argc, char const *argv[])$/;"	f	typeref:typename:int
main	pruebas/prueba_sigson.c	/^int main() {$/;"	f	typeref:typename:int
match_pathcmd	executor/executor.c	/^static char *match_pathcmd(char *cmd, char **enpath, e_errors *err)$/;"	f	typeref:typename:char *	file:
matrixlen	history.c	/^int	matrixlen(char **matrix)$/;"	f	typeref:typename:int
matrixlen	paluego_jose/history.c	/^int	matrixlen(char **matrix)$/;"	f	typeref:typename:int
max_fill	libft/headers/ring.h	/^	int max_fill;$/;"	m	struct:s_ring	typeref:typename:int
memcpy_backwards	libft/src/ft_memmove.c	/^static void	memcpy_backwards(void *dest, const void *src, size_t n)$/;"	f	typeref:typename:void	file:
minishell.h	.vscode/settings.json	/^		"minishell.h": "c",$/;"	s	object:files.associations
next	libft/headers/libft.h	/^	struct s_list	*next;$/;"	m	struct:s_list	typeref:struct:s_list *
next	minishell.h	/^	int next;\/\/posicion no inicializada (null) donde podemos escribir la siguiente variable globa/;"	m	struct:s_environ	typeref:typename:int
non_pipable_builtin	builtins/non_pipable_builtin.c	/^int non_pipable_builtin(t_tree *tree, t_environ *environ)$/;"	f	typeref:typename:int
none	minishell.h	/^	none,$/;"	e	enum:e_symbols
nullify_delimiters	parser/2_build_tree/str_utils.c	/^void	nullify_delimiters(char *str)$/;"	f	typeref:typename:void
ostream	.vscode/settings.json	/^		"ostream": "c"$/;"	s	object:files.associations
outfile	minishell.h	/^	char		*outfile;$/;"	m	struct:s_redir	typeref:typename:char *
outfile	minishell.h	/^	outfile,\/\/>$/;"	e	enum:e_symbols
outsymbol	minishell.h	/^	e_symbols	outsymbol;\/\/>> o >$/;"	m	struct:s_redir	typeref:typename:e_symbols
parse_task	parser/2_build_tree/build_tree.c	/^int parse_task(char *segment, char *end, t_task *task)$/;"	f	typeref:typename:int
parse_test	Makefile	/^parse_test: debug test\/parse-test.o$/;"	t
parsepipe	parser/2_build_tree/build_tree.c	/^int parsepipe(char *line, t_tree **ret)\/\/ desde aqui gestionar solo errores de ejecución, no /;"	f	typeref:typename:int
path_selector	APUNTES/pipex_gethpath.c	/^static int	path_selector(char *pathname, char **paths, char *command)$/;"	f	typeref:typename:int	file:
pid	minishell.h	/^	int   pid; $/;"	m	struct:s_task	typeref:typename:int
pointers	minishell.h	/^	void	**pointers;$/;"	m	struct:s_garbage	typeref:typename:void **
prepare_expansion	paluego_jose/expansor.c	/^static int	prepare_expansion(char **origin, char **new_str, char *envp[])$/;"	f	typeref:typename:int	file:
prepare_expansion	parser/1_expansor/expansor.c	/^static int	prepare_expansion(char **origin, char **new_str, t_garbage *garbage, char *envp[])$/;"	f	typeref:typename:int	file:
print_env	mooks.c	/^void print_env(t_environ *environ)$/;"	f	typeref:typename:void
print_error	main.c	/^void print_error(char *cmd, char *error_msg) \/\/USADA EN IMPRIMIR ERRORES DE PROCESO HIJO$/;"	f	typeref:typename:void
print_tree	mooks.c	/^void print_tree(t_tree *node, int depth)$/;"	f	typeref:typename:void
put_line	GNL/get_next_line.c	/^int	put_line(char **line, char **aux, int reader)$/;"	f	typeref:typename:int
re	Makefile	/^re: fclean all$/;"	t
re	libft/Makefile	/^re: fclean all$/;"	t
readline.h	.vscode/settings.json	/^		"readline.h": "c",$/;"	s	object:files.associations
redir	minishell.h	/^	t_redir 	redir;$/;"	m	struct:s_task	typeref:typename:t_redir
repipe_child	executor/executor.c	/^static e_errors repipe_child(t_task *task, int in, int out, char **word_fail)$/;"	f	typeref:typename:e_errors	file:
rigth	minishell.h	/^	t_tree	*rigth;$/;"	m	struct:s_pipe	typeref:typename:t_tree *
ring_add_head	libft/ring_array/ring_add_head.c	/^int ring_add_head(t_ring *ring, int new_element)$/;"	f	typeref:typename:int
ring_find_bigest	libft/ring_array/ring_find_bigest.c	/^int ring_find_bigest(t_ring *ring)$/;"	f	typeref:typename:int
ring_find_smallest	libft/ring_array/ring_find_smallest.c	/^int ring_find_smallest(t_ring *stack)$/;"	f	typeref:typename:int
ring_find_value	libft/ring_array/ring_find_value.c	/^t_level ring_find_value(t_ring *ring, int value)$/;"	f	typeref:typename:t_level
ring_free	libft/ring_array/ring_free.c	/^void	ring_free(t_ring *ring)$/;"	f	typeref:typename:void
ring_get_head	libft/ring_array/ring_get_head.c	/^int ring_get_head(t_ring *ring)$/;"	f	typeref:typename:int
ring_get_level	libft/ring_array/ring_get_level.c	/^int ring_get_level(const t_ring *ring, t_level level) $/;"	f	typeref:typename:int
ring_get_tail	libft/ring_array/ring_get_tail.c	/^int ring_get_tail(t_ring *ring)$/;"	f	typeref:typename:int
ring_has_duplicates	libft/ring_array/ring_has_duplicates.c	/^bool	ring_has_duplicates(t_ring *a)$/;"	f	typeref:typename:bool
ring_index_get_level	libft/ring_array/ring_index_get_level.c	/^int ring_index_get_level(t_ring *ring, int index)$/;"	f	typeref:typename:int
ring_init	libft/ring_array/ring_init.c	/^t_ring	*ring_init(int size)$/;"	f	typeref:typename:t_ring *
ring_next_index	libft/ring_array/ring_next_index.c	/^int ring_next_index(int index, int slots)$/;"	f	typeref:typename:int
ring_pop_head	libft/ring_array/ring_pop_head.c	/^int	ring_pop_head(t_ring *ring)$/;"	f	typeref:typename:int
ring_prev_index	libft/ring_array/ring_prev_index.c	/^int ring_prev_index(int index, int slots)$/;"	f	typeref:typename:int
ring_push	libft/ring_array/ring_push.c	/^int ring_push(t_ring *from, t_ring *to)$/;"	f	typeref:typename:int
ring_reverse_rotate	libft/ring_array/ring_reverse_rotate.c	/^int	ring_reverse_rotate(t_ring *ring)$/;"	f	typeref:typename:int
ring_rotate	libft/ring_array/ring_rotate.c	/^int	ring_rotate(t_ring *ring)$/;"	f	typeref:typename:int
ring_swap	libft/ring_array/ring_swap.c	/^int ring_swap(t_ring *ring)\/\/ requiere % ring->slots en algún punto$/;"	f	typeref:typename:int
run_heredoc_sigint_test	minishell_tester.py	/^    def run_heredoc_sigint_test(self):$/;"	m	class:MinishellTester
run_test_file	minishell_tester.py	/^    def run_test_file(self, test_file):$/;"	m	class:MinishellTester
s_environ	minishell.h	/^typedef struct s_environ {$/;"	s
s_garbage	minishell.h	/^typedef struct s_garbage {$/;"	s
s_list	libft/headers/libft.h	/^typedef struct s_list$/;"	s
s_pipe	minishell.h	/^typedef struct s_pipe {$/;"	s
s_redir	minishell.h	/^typedef struct s_redir$/;"	s
s_ring	libft/headers/ring.h	/^typedef struct s_ring$/;"	s
s_task	minishell.h	/^typedef struct s_task$/;"	s
s_tree	minishell.h	/^typedef struct s_tree$/;"	s
save_history	history.c	/^int	save_history(char *history)$/;"	f	typeref:typename:int
save_history	paluego_jose/history.c	/^int	save_history(char *history)$/;"	f	typeref:typename:int
save_limit_history	history.c	/^void	save_limit_history(char *hist, int fd)$/;"	f	typeref:typename:void
save_limit_history	paluego_jose/history.c	/^void	save_limit_history(char *hist, int fd)$/;"	f	typeref:typename:void
search_var	create_envp.c	/^int	search_var(char **envp, const char* var)$/;"	f	typeref:typename:int
send_command	minishell_tester.py	/^    def send_command(self, command):$/;"	m	class:MinishellTester
send_eof	minishell_tester.py	/^    def send_eof(self):$/;"	m	class:MinishellTester
send_sigint	minishell_tester.py	/^    def send_sigint(self):$/;"	m	class:MinishellTester
shell_cycle	main.c	/^void shell_cycle(t_tree *tree, t_environ *environ)$/;"	f	typeref:typename:void
signal_conf	signal.c	/^void	signal_conf(void)$/;"	f	typeref:typename:void
size	minishell.h	/^	int		size;$/;"	m	struct:s_garbage	typeref:typename:int
skip_quotes	parser/2_build_tree/str_utils.c	/^int skip_quotes(char **strpnt, char *end)$/;"	f	typeref:typename:int
skipwhitesp	parser/2_build_tree/str_utils.c	/^void	skipwhitesp(char **segment, char *end)$/;"	f	typeref:typename:void
slots	libft/headers/ring.h	/^	int	slots;$/;"	m	struct:s_ring	typeref:typename:int
sstream	.vscode/settings.json	/^		"sstream": "c",$/;"	s	object:files.associations
start_minishell	minishell_tester.py	/^    def start_minishell(self):$/;"	m	class:MinishellTester
stat.h	.vscode/settings.json	/^		"stat.h": "c",$/;"	s	object:files.associations
stdio.h	.vscode/settings.json	/^		"stdio.h": "c",$/;"	s	object:files.associations
strnchr_outquot	parser/2_build_tree/str_utils.c	/^int strnchr_outquot(char **str, char *end, char c)$/;"	f	typeref:typename:int
t_environ	minishell.h	/^}	t_environ;$/;"	t	typeref:struct:s_environ
t_garbage	minishell.h	/^}	t_garbage;$/;"	t	typeref:struct:s_garbage
t_level	libft/headers/ring.h	/^typedef int t_level;$/;"	t	typeref:typename:int
t_list	libft/headers/libft.h	/^}	t_list;$/;"	t	typeref:struct:s_list
t_pipe	minishell.h	/^}	t_pipe;$/;"	t	typeref:struct:s_pipe
t_redir	minishell.h	/^}	t_redir;$/;"	t	typeref:struct:s_redir
t_ring	libft/headers/ring.h	/^}	t_ring;$/;"	t	typeref:struct:s_ring
t_task	minishell.h	/^}	t_task;$/;"	t	typeref:struct:s_task
t_tree	minishell.h	/^}	t_tree;$/;"	t	typeref:struct:s_tree
tail	libft/headers/ring.h	/^	int	tail;$/;"	m	struct:s_ring	typeref:typename:int
ten_pow	libft/src/ft_putnbr_fd.c	/^static int	ten_pow(int n)$/;"	f	typeref:typename:int	file:
test_fds	mooks.c	/^void test_fds(char *where)$/;"	f	typeref:typename:void
tester	minishell_tester.py	/^    tester = MinishellTester()$/;"	v
tmp_file	minishell.h	/^	char		*tmp_file;\/\/Es creado en caso de insymbol << por la funcion heredoc_handler requiere un/;"	m	struct:s_redir	typeref:typename:char *
touch_up_tree	parser/3_touch_up_tree.c	/^e_errors	touch_up_tree(t_tree *node, char *envp[])$/;"	f	typeref:typename:e_errors
type	minishell.h	/^	e_nodes		type;$/;"	m	struct:s_task	typeref:typename:e_nodes
type	minishell.h	/^	e_nodes	type;$/;"	m	struct:s_pipe	typeref:typename:e_nodes
type	minishell.h	/^	e_nodes	type;$/;"	m	struct:s_redir	typeref:typename:e_nodes
type	minishell.h	/^	e_nodes type;$/;"	m	struct:s_tree	typeref:typename:e_nodes
unquote	parser/3_touch_up_tree.c	/^void unquote(char *str)$/;"	f	typeref:typename:void
unquote_one	parser/3_touch_up_tree.c	/^char *unquote_one(char **pntnew, char *pntstr)$/;"	f	typeref:typename:char *
unquote_task	parser/3_touch_up_tree.c	/^static void unquote_task(t_task *node)$/;"	f	typeref:typename:void	file:
validate_key	builtins/non_pipable_builtin.c	/^int validate_key(char *key)$/;"	f	typeref:typename:int
var_expansion_len	parser/1_expansor/expansor_utils.c	/^static int	var_expansion_len(char **str, char *envp[])$/;"	f	typeref:typename:int	file:
var_name_len	parser/1_expansor/expansor_utils.c	/^size_t var_name_len(char *str, char **envp)$/;"	f	typeref:typename:size_t
wait_all	executor/process.c	/^int wait_all(t_tree *node)\/\/, char **envp)$/;"	f	typeref:typename:int
write_heredoc_fork	parser/create_heredoc.c	/^static e_errors write_heredoc_fork(int fd, char *separator, size_t seplen)$/;"	f	typeref:typename:e_errors	file:
write_heredoc_line	parser/create_heredoc.c	/^static e_errors write_heredoc_line(int fd, char *separator, size_t seplen)$/;"	f	typeref:typename:e_errors	file:
